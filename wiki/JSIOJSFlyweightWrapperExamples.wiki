#summary Example code using JSFlyweightWrapper
 
= JSIO JSWrapper JSFlyweight Example code =

The following example shows how to create a wrapper to the !TextThingo !JavaScript API above using the JSFlyweightWrapper interface and a constructor function.

== Hello World using JSFlyweightWrapper ==

This example shows how to implement the Hello World example using JSFlyweightWrapper:

{{{

  /*
   * HelloJSWrapper.java
   * A wrapper around a single !JavaScript object property named 'hello'
   * using the JSFlyweight interface.
   */

  @BeanProperties
  interface HelloWrapperFw extends JSFlyweightWrapper {
    static HelloWrapperFw impl = GWT.create(HelloWrapperFw.class);

   
    @Constructor("$wnd.Hello")
    JavaScriptObject construct();

    public String getHello(JavaScriptObject jso);
  }

  JavaScriptObject jso = 
     JSONWrapperUtil.evaluate("{hello:'Hello World!'}");
    
  String message = HelloWrapperFw.impl.getHello(jso);
  Window.alert(message);

}}}


== Instantiating a JavaScript object using a constructor ==

This example uses the same JavaScript API used in the [JSIOJSWrapperExamples JSWrapper Example]:

{{{
// Create a new TextThingo object
// e - bounding box element to attach to
// value - a string to display
function TextThingo (e, value) {
  this.textValue = value;
  this.text = document.createElement("span");
  e.appendChild(this.text);
}

// Display the current value in the TextThingo object
TextThingo.prototype.show = function () {
  // remove all children
  while (this.text.FirstChild) {
    this.text.removeChild(text.firstChild());
  }
  this.text.appendChild(document.createTextNode(this.textValue));
}
}}}

=== Interface definition ===

The code is similar to the `JSWrapper` example, but a static instance of the generated class is created and stored within the Flyweight object.  Note that each accessor method contains a `JavaScriptObject` as the first parameter:

{{{

@BeanProperties
public interface TextThingoFW extends JSFlyweightWrapper {
  /** 
   * You only need to instantiate TextThingoFW once, so we save it in
   * a static field in the class itslef.  The generated method calls
   * are shared between all instances created by the construct() method.
   * This makes the JavaScript code generated by JSFlyweightWrapper
   * more efficient than that generated by JSWrapper.
   */
  public static final TextThingoFW impl = 
    (TextThingoFW) GWT.create(TextThingoFW.class);
  
  @Constructor("$wnd.TextThingo")
  public JavaScriptObject construct(Element container, String value);

  /* Automatically created bean method to access option property */
  public String getTextValue(JavaScriptObject jsoPeer);

  /* Automatically created bean method to access option property */
  public void setTextValue(JavaScriptObject jsoPeer, String value);

  /* Maps to the JavaScript start() function on the TextThingo object */
  public void show(JavaScriptObject jsoPeer);
}
}}}


=== Instantiating the Interface with Deferred Binding ===


Now, to use the API, you access the generated instance through the
`impl` static variable.  The constructor will return a native
JavaScriptObject which you must use each time you wish to access the
object. 

{{{
  private JavaScriptObject jsoPeer;

  public void onModuleLoad() {

    // A GWT container for our JavaScript API object.
    Panel s = new SimplePanel();
    
    // Create an instance of a TextThingo in JavaScript, store away the resulting
    // JavaScript object for future calls through the TextThingoFW interface.
    jsoPeer = TextThingoFW.impl.construct(s.getElement(), "Hello Flyweight World!");   
    
    TextThingoFW.impl.setTextValue(jsoPeer, "Goodbye Cruel Flyweight World!");
    TextThingoFW.impl.show(jsoPeer);

    // Add the panel containing the text thingo to the interface.
    RootPanel.get("elementId").add(s);
  }
}}}

== Using a callback with JSFlyweightWrapper ==

To integrate a callback style !JavaScript API with GWT, create a subclass of !JSFunction.

=== JavaScript API ===

Consider the following !JavaScript API that takes a function as a parameter to some methods:

{{{
// Example of a JavaScript API that requires a callback function

// Constructor for the ThreeButton object
// e - element ot attach the three buttons to
// cb - callback to use whenever the buttons are pressed
// button1Name - string to use for text in button 1
// button2Name - string to use for text in button 2
function TwoButton (e, cb, button1Name, button2Name) {

  this.id = "TwoButton";
  
  this.button1 = document.createElement("button");
  button1Name = 
    button1Name !== undefined ? button1Name : "One";
  this.button1.appendChild(document.createTextNode(button1Name));
 
  this.button2 = document.createElement("button");
  button2Name = 
      button2Name !== undefined ? button2Name : "Two"; 
  this.button2.name = this.button2.value;

  this.button2.appendChild(document.createTextNode(button2Name));
  
  e.appendChild(this.button1);
  e.appendChild(this.button2);
  
  this.addCallback(cb);
}

// Change the callback function
// cb - callback to use whenever the buttons are pressed. 
//      Replaces the previous setting
TwoButton.prototype.addCallback = function (cb) {

  // Create a closure to use to invoke the callback function.  
  var meCb = function (buttonNumber) { cb (buttonNumber); };
  this.button1.onclick = function () { meCb(1) };
  this.button2.onclick = function () { meCb(2) };
}

}}}

=== Interface Definition ===

A !JavaScript API that takes a function as a parameter requires creating a subclass of the `JSFunction` class.  The definition of `TwoButtonCallback` below allows the !JavaScript API to invoke a Java function as a callback.

Note that we are fortunate in this instance, as the callback function's parameters consists only of JSIO compatible types.  See the rules for which types are compatible in the description of the `JSWrapper` interface above.

{{{
/**
 * A wrapper for the TwoButton JavaScript API.  This API requires
 * a callback function which we wish to specify in Java.
 */
public interface TwoButtonFW extends JSFlyweightWrapper {

  /**
   * A definition of a callback class.  Must extend JSFunction
   */
  public abstract static class TwoButtonCallback extends JSFunction {
    public abstract void callback (int buttonNumber);
  }
  
  public static final TwoButtonFW impl = 
    (TwoButtonFW) GWT.create(TwoButtonFW.class);
  
  
  @Constructor("$wnd.TwoButton") 
  public JavaScriptObject construct(
      Element container, TwoButtonCallback cb, String buttonOneText, 
      String buttonTwoText);
  
  @BeanProperties
  public String getId(JavaScriptObject jsoPeer);
  
  public void addCallback (JavaScriptObject jsoPeer, TwoButtonCallback cb);
  
}
}}}

=== Instantiating the Interface ===

The following code demonstrates how to use the TwoButtonFW interface:

{{{
/**
 * This example shows how to use the wrapper class for the TwoButton JavaScript
 * API.  It instantiates an instance of TwoButton.  Each time the callback is
 * invoked, an alert window is display, then the callback is swaped between 
 * cb1 and cb2.
 */
public class JSFlyweightWrapperCallbackExample implements EntryPoint {

  private JavaScriptObject jsoPeer;
  private TwoButtonCallback cb2;
  private TwoButtonCallback cb1;

  public void onModuleLoad() {
    Panel s = new SimplePanel();

    cb1 = new TwoButtonCallback() {
      @Override
      public void callback(int buttonNumber) {
        Window.alert("Got TwoButton Callback for button: " + buttonNumber);
        TwoButtonFW.impl.addCallback(jsoPeer, cb2);
      }
    };

    cb2 = new TwoButtonCallback() {
      @Override
      public void callback(int buttonNumber) {
        Window.alert("Replaced callback. Got button: " + buttonNumber);
        TwoButtonFW.impl.addCallback(jsoPeer, cb1);
      }
    };

    jsoPeer = TwoButtonFW.impl.construct(s.getElement(), cb1, "Button One (1)",
        "Button Two (2)");

    // Add the panel containing the TwoButton object to the interface.
    RootPanel.get("elementId").add(s);
  }
}
}}}

== Invoking a method defined in Java from a JavaScript API ==

This example demonstrates one way to invoke a Java method from JavaScript.  In this example, both the called and calling code are wrapped using JSIO.


{{{
function A () {
  this.dummy = "foo";
}

A.prototype.myMethod = function (b) {
  window.alert(b.retrieveMessage());
}

//  Example invocation using the above API.
//
var count = 0;

function invokeApi () {
  var a = new A();
  var b = new Object();
  b.retrieveMessage = function () { 
     count++; 
     return "Hello World! "+count; 
  };
       
  a.myMethod(b);
}

}}}


First, wrap A using JSFlyweightWrapper:

{{{
  public interface AWrapper extends JSFlyweightWrapper {
    
    static AWrapper impl = GWT.create(AWrapper.class);

    @Constructor("$wnd.A")
    JavaScriptObject construct();

    /*
     * A function in the JavaScript API we want to call and pass an instance
     * containing a function defined in Java to.
     */
    void myMethod(JavaScriptObject jso, B bObject);
  }
}}}

Next, we need to define a class to hold our new function that we are going to attach to the JavaScript B object.  The method to be exported is annotated with `@Exported`.  The `jsoPeer` field is used later:

{{{

  public abstract static class B {
    /*
     * The jsoPeer field is referenced by the code generated by 
     * JSFlyweightWrapper when an instnance of this class is used as a
     * parameter to a method call.
     */
    protected JavaScriptObject jsoPeer;

    /**
     * A JavaScript API expects the function myMethod() as a property in this
     * object, so we need to export it.
     */
    @Exported
    public abstract String retrieveMessage();
  }
}}}

Now define a Wrapper class that extends !JSFlyweightWrapper.  A constructor is needed. If you want to add functions to an existing !JavaScript class, you can change the target of the `@Constructor` annotation.  In this case, we are adding the function to a plain !JavaScript object.

{{{

  interface BWrapper extends JSFlyweightWrapper {

    static BWrapper impl = GWT.create(BWrapper.class);

    /**
     * Indicates that the method should be used to export methods from a Java
     * object to a JSO.
     */
    @Binding
    public void bind(JavaScriptObject obj, B bObject);

    @Constructor("Object")
    public JavaScriptObject construct();
  }
}}}

Next, define the actual implementation of the methods to be exported from Java into JavaScript.  This class must contain a constructor that accepts a JavaScriptObject.  This constructor is invoked using a JavaScriptObject returned from the BWrapper construct() method.

{{{

  static class BImplementation extends B {

    public BImplementation(JavaScriptObject jso) {
      jsoPeer = jso;
    }

    @Override
    public String retrieveMessage() {
      numInvocations++;
      return "Hello World! " + numInvocations;
    }
  }

}}}

Finally, here is the driver code for the sample classes.  After creating an instance of BWrapper, you must create BImplementation using the new JavaScriptObject, and then you must call the `bind()` method to tie the two together in the other direction. 

{{{
  static int numInvocations;

  JavaScriptObject jsoPeerA; // an instance of class 'A'
  JavaScriptObject jsoPeerB; // an instance of class 'B'

  /**
   * This is the entry point method.
   */
  public void onModuleLoad() {
    Panel s = new SimplePanel();
    Button button = new Button("Click to show window");
    s.add(button);

    button.addClickListener(new ClickListener() {

      public void onClick(Widget sender) {
        jsoPeerB = BWrapper.impl.construct();

        // Create a new instance of Bimplementation that references jsoPeerB
        BImplementation bImpl = new BImplementation(jsoPeerB);

        // Add another reference from jsoPeerB to bImpl
        BWrapper.impl.bind(jsoPeerB, bImpl);
        
        jsoPeerA = AWrapper.impl.construct();
        AWrapper.impl.myMethod(jsoPeerA, bImpl);
      }
    });

    // Add the panel button to the interface.
    RootPanel.get("elementId").add(s);
  }
}}}