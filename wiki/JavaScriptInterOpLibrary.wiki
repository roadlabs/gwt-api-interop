#summary The !JavaScript Interoperability (JSIO) library simplifies binding a !JavaScript API to GWT
= Introduction =

This document describes the !JavaScript Interoperability( JSIO) library for the Google Web Toolkit (GWT).  These classes are for importing existing !JavaScript APIs and exporting Java functions to be used !JavaScript code.

Using this library, the GWT compiler can automatically generate:

    * Linkage to functions defined within a [http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/core/client/JavaScriptObject.html com.google.gwt.core.client.JavaScriptObject]
    * Exports of Java functions to be made available to !JavaScript callers
    * Accessors for bean-style properties

Developers extend `JSWrapper` or `JSFlyweightWrapper` to create interface definitions to access the !JavaScript object.  To use the interface, the GWT deferred binding mechanism `GWT.create()` is invoked to return an instance of the interface created through automatically generated code.

=JSWrapper interface=

Any method defined in an interface that extends [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSWrapper.html com.google.gwt.jsio.client.JSWrapper] or an abstract method in a class that implements  [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSWrapper.html com.google.gwt.jsio.client.JSWrapper] will be acted upon by the compiler. The default behavior is to invoke an identically-named method on the underlying [http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/core/client/JavaScriptObject.html com.google.gwt.core.client.JavaScriptObject]. This behavior may be altered by the presence of various annotations on the class and its methods.

The parameter and return types supported by JSWrapper are:

    * primitive
    * boxed primitive
    * java.lang.String
    * [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSFunction.html com.google.gwt.jsio.client.JSFunction]
    * [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSWrapper.html com.google.gwt.jsio.client.JSWrapper]
    * [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSList.html
com.google.gwt.jsio.client.JSList] having a compatible component type specified with the gwt.typeArgs annotation
    * [http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/core/client/JavaScriptObject.html com.google.gwt.core.client.JavaScriptObject] and subtypes
    * [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSOpaque.html com.google.gwt.jsio.client.JSOpaque] as a method parameter only.

In the general case, there may be at most one [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSWrapper.html com.google.gwt.jsio.client.JSWrapper] associated with a [http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/core/client/JavaScriptObject.html com.google.gwt.core.client.JavaScriptObject JavaScriptObject]. This allows the JSWrapper to maintain an object identity equivalent to that of the underlying !JavaScriptObject. This is done by adding an additional property, `__gwtObject`, to the !JavaScriptObject.
Annotations

The behavior of the generated classes may be altered by the presence of various @gwt annotations.

||Annotation 	        ||Location 	||Description ||
|| `gwt.beanProperties`    ||Class, Method || Indicates that methods that look like bean-style property setters (methods that begin with the prefix `get`, `set`, or `is`) should be generated so as to read and write object properties rather than import functions. This is most useful with JSON-style objects. The setting may by applied on a per-method basis in an imported class and may by overridden on a per-method basis by `gwt.imported`. If the backing object does not contain data for a property accessor, null, 0, ' ', false, or an empty [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSList.html com.google.gwt.jsio.client.JSList] will be returned. ||
|| `gwt.constructor` 	||Class, Method  || The annotation `gwt.constructor` may be applied to a class to specify a !JavaScript function to execute when constructing a JSWrapper to use as the initial backing object. A !JavaScript Date object could be created by using the value $wnd.Date. If the gwt.constructor annotation is applied to a method within a JSWrapper and the method invoked, the parameters of the method will be passed to the named global function and the resulting !JavaScript object will be used as the backing object. ||
|| `gwt.exported` 	||Method 	||Individual Java functions may be exported to !JavaScript callers by declaring a `gwt.exported` annotation on a concrete Java method within a JSWrapper. The Java method will be bound to a property on the backing object per the class' !NamePolicy or a `gwt.fieldName` annotation on the method. When applied at the class level to a [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSFunction.html com.google.gwt.jsio.client.JSFunction], it specifies which of the methods declared within to type to export as a !JavaScript Function object.||
|| `gwt.fieldName` 	||Method 	||When implementing a bean property accessor, the default !NamePolicy will be used unless a `gwt.fieldName` annotation appears on the property's getter or setter. This is also used with imported and exported functions to specify the object property to attach to.||
|| `gwt.global` 	||Class 	||The annotation `gwt.global` is similar to gwt.constructor, however it may be applied only at the class level and the value is interpreted as a globally-accessible object name, rather than a function. ||
|| `gwt.imported` 	||Method 	||This is an override for methods within classes annotated with `gwt.beanProperties`.||
|| `gwt.namePolicy` 	||Class 	||Specifies the default transformation to use when converting bean property accessor function names to fields on the underlying !JavaScriptObject. The valid values for the namePolicy are the field names on the `com.google.gwt.jsio.rebind.NamePolicy` class, or the name of a class that implements !NamePolicy.||
|| `gwt.noIdentity` 	||Class 	||This annotation suppresses the addition of the __gwtObject property on the underlying !JavaScriptObject. The object identity of the JSWrapper will no longer maintain a 1:1 correspondence with the underlying !JavaScriptObject. Additionally,  [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSWrapper.html#setJavaScriptObject(JavaScriptObject) com.google.gwt.jsio.client.JSWrapper.setJavaScriptObject()] will no longer throw [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/MultipleWrapperException.html com.google.gwt.jsio.client.MultipleWrapperException].  ||
|| `gwt.readOnly`	||Class 	||This prevents the generated JSWrapper implementation from containing any code that will modify the underlying !JavaScriptObject. This implies `gwt.noIdentity`. Invoking a bean-style getter when the underlying !JavaScriptObject does not contain a value for the property will result in undefined behavior. ||


==JSWrapper Examples==

The following examples demonstrate how to write an interface that maps onto a !JavaScript object to access it from GWT code.


=== Hello World using JSWrapper ===

This simple example demonstrates how to access a property in a !JavaScript Object (JSO).

{{{
/*
 * HelloJSIO.java
 * A simple wrapper around a single !JavaScript object property named 'hello'
 */

/**
 * @gwt.beanProperties
 */
interface HelloWrapper extends JSWrapper {
  public String getHello();
}
HelloWrapper hello = (HelloWrapper)GWT.create(HelloWrapper.class);
hello.setJSONData("{hello:'Hello world'}");
Window.alert(hello.getHello());
}}}


=== Mixing Access to !JavaScript Object with other methods ===

The following example uses several JSIO features:

 * Some bean accessor methods are created.
 * A concrete Java method is defined in the JSO.
 * A !JavaScript function is imported from !JavaScript to Java.

{{{
/**
 * @gwt.beanProperties
 */
abstract class MixedWrapper implements JSWrapper {

  // Property accessor - read the property named 'a'
  public abstract int getA();

  // Property accessor - read the property named 'b'
  public abstract int getB();

  // Property accessor - write to the property named 'b'
  public abstract int setB();

  // Method that is implemented in Java that will be translated to 
  // JavaScript and set in the JavaScript Object.
  public int multiply() {
    return getA() * getB();
  }

  // This method would be imported at some point. JSIO supports 
  // "duck-typing" - if no function with the name 'importedFunction()' 
  // is defined in the object at the time the method is invoked, 
  // you will get a run-time error.
  public abstract int importedFunction(String s);

}
}}}

The following demonstrates how to use the new wrapper:

{{{
  MixedWrapper wrapper = (MixedWrapper)GWT.create(MixedWrapper.class);
  wrapper.setJSONData("{a:2, b:5}");
  Window.alert(wrapper.multiply());
  wrapper.setB(10);
  Window.alert(wrapper.multiply());
}}}

Running the code would show you the value `10` in the first window, then `20` in the second window.

== Instantiating a !JavaScript object using a constructor ==

If you have a !JavaScript library that is written in an object oriented fashion, you can map a function in a JSWrapper class to the !JavaScript constructor instead of using the `setJSONData()` or `setJavaScriptObject()`.

Suppose you wanted to access the following !JavaScript API:

{{{

// Create a new TextThingo object
// e - bounding box element to attach to
// value - a string to display
function TextThingo (e, value) {
  this.textValue = value;
  this.text = document.createElement("span");
  e.appendChild(this.text);
}

// Display the current value in the TextThingo object
TextThingo.prototype.show = function () {
  // remove all children
  while (this.text.FirstChild) {
    this.text.removeChild(text.firstChild());
  }
  this.text.appendChild(document.createTextNode(this.textValue));
}
}}}

This API would be used in !JavaScript as follows:

{{{
  var t = new TextThingo (document.getElementById("elementId"), "Hello World!");
  t.textValue = "Goodbye Cruel World!";
  t.show();
}}}

And the resulting web page would display the text, "Goodbye Cruel World" in an element declared with ID "elementId" in the host HTML page. 

Now, we will wrap the API using JSIO so we can access it from GWT.  The following code shows how to wrap the constructor, the start() method, and create bean accessors to the textValue property:

{{{
/**
 * @gwt.beanProperties
 */
public interface TextThingo extends JSWrapper {

  /**
   * @gwt.constructor $wnd.TextThingo
   */
  public TextThingo construct(Element container, String value);

  /* Automatically created bean method to access option property */
  public void setTextValue(String value); 

  /* Automatically created bean method to access option property */
  public String getTextValue();

  /* Maps to the JavaScript start() function on the TextThingo object */
  public void show();

}
}}}

You will need to add the JSIO `<inherits>` line to your _<module>_`.gwt.xml` file.

{{{
<module>

  <!-- Inherit the core Web Toolkit stuff.                  -->
  <inherits name='com.google.gwt.user.User' />
  <inherits name='com.google.gwt.jsio.JSIO' />
  
  <!-- Specify the app entry point class.                   -->
  <entry-point class='com.example.gwt.client.JSWrapperExample' />

</module>

}}}

Now to use the wrapper, you need to use GWT.create() to invoke the JSIO generators, then run the `construct()` method to instantiate the !JavaScript object:

{{{
  private TextThingo textThingo;

  void onModuleLoad () {
    Panel s = new SimplePanel();
    textThingo = GWT.create(TextThingo.class);
 
    // Don't call any other methods in the new object until the 'construct' method is called.
    textThingo.construct(s.getElement(), "Hello World!");

    textThingo.setTextValue("Goodbye Cruel World!");
    textThingo.show();

    // Add the panel containing the text thingo to the interface.
    RootPanel.get("elementId").add(s);
  }

}}}

== Generated Code ==

The code below is the output of the JSIO `JSWrapper` generator for
the `TestThingo` interface:

{{{
package com.example.gwt.client;

import com.google.gwt.jsio.client.impl.*;
import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.jsio.client.*;
import com.google.gwt.core.client.GWT;

public class __TextThingoImpl implements com.example.gwt.client.TextThingo {
  private JavaScriptObject jsoPeer;
  public __TextThingoImpl() {
    setJavaScriptObject(__nativeInit());
  }
  private native JavaScriptObject __nativeInit() /*-{
    return null;
  }-*/;

  public JavaScriptObject getJavaScriptObject() {
    return jsoPeer;
  }

  public void setJSONData(String data)  throws JSONWrapperException {
    setJavaScriptObject(JSONWrapperUtil.evaluate(data));
  }

  public JSWrapper setJavaScriptObject(JavaScriptObject obj) {
    if (obj != null) {
      assert JSONWrapperUtil.hasField(obj, "show") : "Backing JSO missing imported function show";
    }
    return setJavaScriptObjectNative(obj);
  }

  public native JSWrapper setJavaScriptObjectNative(JavaScriptObject obj) /*-{
    if (this.@com.example.gwt.client.__TextThingoImpl::jsoPeer) {
      delete this.@com.example.gwt.client.__TextThingoImpl::jsoPeer.__gwtPeer;
    }
    if (!obj) {
      this.@com.example.gwt.client.__TextThingoImpl::jsoPeer = null;
      return this;
    }
    if (obj.__gwtPeer) {
      @com.google.gwt.jsio.client.impl.JSONWrapperUtil::throwMultipleWrapperException()();
    }
    this.@com.example.gwt.client.__TextThingoImpl::jsoPeer = obj;
    this.@com.example.gwt.client.__TextThingoImpl::jsoPeer.__gwtPeer = this;
    this.@com.example.gwt.client.__TextThingoImpl::__initializeEmptyFields(Lcom/google/gwt/core/client/JavaScriptObject;)(this.@com.example.gwt.client.__TextThingoImpl::jsoPeer);
    return this;
  }-*/;

  public final Extractor getExtractor() {
    return __extractor;
  }

  private final static Extractor __extractor = new Extractor() {public native Object fromJS(JavaScriptObject obj) /*-{
      return obj == null ? null : (obj.__gwtPeer || @com.example.gwt.client.__TextThingoImpl::__create__com_example_gwt_client_TextThingo()().@com.google.gwt.jsio.client.JSWrapper::setJavaScriptObject(Lcom/google/gwt/core/client/JavaScriptObject;)(obj));
    }-*/;
    public native JavaScriptObject toJS(Object obj) /*-{
      return obj == null ? null : obj.@com.google.gwt.jsio.client.JSWrapper::getJavaScriptObject()();
    }-*/;
  };

  private native void __initializeEmptyFields(JavaScriptObject jso) /*-{
    if (!jso.hasOwnProperty('textValue')) {
      jso.textValue = null;
    }
  }-*/;

  public native void show() /*-{
    this.@com.example.gwt.client.__TextThingoImpl::jsoPeer.show();
  }-*/;

  public native java.lang.String getTextValue() /*-{
    return this.@com.example.gwt.client.__TextThingoImpl::jsoPeer.textValue;
  }-*/;

  public native void setTextValue(java.lang.String value) /*-{
    this.@com.example.gwt.client.__TextThingoImpl::jsoPeer.textValue = value;
  }-*/;

  public native com.example.gwt.client.TextThingo construct(com.google.gwt.user.client.Element container, java.lang.String value) /*-{
    var jsReturn = new $wnd.TextThingo(container, value);
    return this.@com.google.gwt.jsio.client.JSWrapper::setJavaScriptObject(Lcom/google/gwt/core/client/JavaScriptObject;)(jsReturn);
  }-*/;

  private static com.example.gwt.client.TextThingo __create__com_example_gwt_client_TextThingo() {
    return (com.example.gwt.client.TextThingo)GWT.create(com.example.gwt.client.TextThingo.class);
  }
}
}}}


== Invoking a method defined in Java from a JavaScript API ==

Consider the following API defined in JavaScript:

{{{
function A () {
  this.dummy = "foo";
}

A.prototype.myMethod = function (b) {
  window.alert(b.retrieveMessage());
}

function B () {
  this.dummy = "bar";
}

//  Example invocation using the above API.
//
var count = 0;

function invokeApi () {
  var a = new A();
  var b = new B();
  b.retrieveMessage = function () { 
     count++; 
     return "Hello World! "+count; 
  };
       
  a.myMethod(b);
}

}}}


The developer is expected to add a function to 'B' to return a string used in the `myMethod()` function.  In GWT, the developer will want to write the definition of `retrieveMessage()` in Java.  For this to work correctly in hosted mode, JSIO must generate special interface code.  For this to work correctly in Web mode, the compiler must be told to preserve the name of the `retrieveMessage()` method.

Wrapping the `A` object is straightforward with JSWrapper.  Note that in this case since our constructor takes no argument, we can annotate with `@gwt.constructor` at the class level:

{{{
import com.google.gwt.jsio.client.JSWrapper;

/**
 * 
 * @gwt.constructor $wnd.A
 *
 */
public interface A extends JSWrapper {
    
    /* A function in the JavaScript API we want to call and pass an instance
     * containing a function defined in Java to.
     */
    void myMethod (B bObject);
    
}
}}}

The `B` object needs to be wrapped in a different way.  Since we are extending it by adding a new method, we cannot represent it with a Java interface.  Instead, we use an abstract class.  The class extends JSWrapper and makes use of the @gwt.exported annotation on the functions that are inteded to be called from within JavaScript:

{{{
import com.google.gwt.jsio.client.JSWrapper;

/**
 * 
 * @gwt.constructor $wnd.B
 *
 */
public abstract class B implements JSWrapper {
  static int numInvocations = 0;

  /**
   * A JavaScript API expects the function myMethod() as a property in
   * this object, so we need to export it.
   * 
   * @gwt.exported
   */
  public String retrieveMessage() {
    numInvocations++;
    return "Hello World! "+numInvocations;
  }
}
}}} 

=== Instantiating the interface ===

Below is an example of how to invoke the API from a GWT project:

{{{

 public void onModuleLoad() {
    Panel s = new SimplePanel();
    Button button = new Button("Click to show window");
    s.add(button);
    
    button.addClickListener(new ClickListener() {

      public void onClick(Widget sender) {
        A a = GWT.create(A.class);
        B b = GWT.create(B.class);
        a.myMethod(b);
      }
      
    });
   
    // Add the panel button to the interface.
    RootPanel.get("elementId").add(s);
  }
}}}

=== Generated Code ===

__AImpl.java
{{{
  

public class __AImpl implements com.example.gwt.client.A {
  private JavaScriptObject jsoPeer;
  public __AImpl() {
    setJavaScriptObject(__nativeInit());
  }
  private native JavaScriptObject __nativeInit() /*-{
    return new $wnd.A();
  }-*/;
  public JavaScriptObject getJavaScriptObject() {
    return jsoPeer;
  }
  public void setJSONData(String data)
  throws JSONWrapperException {
    setJavaScriptObject(JSONWrapperUtil.evaluate(data));
  }
  public JSWrapper setJavaScriptObject(JavaScriptObject obj) {
    if (obj != null) {
      assert JSONWrapperUtil.hasField(obj, "myMethod") : "Backing JSO missing imported function myMethod";
    }
    return setJavaScriptObjectNative(obj);}
  public native JSWrapper setJavaScriptObjectNative(JavaScriptObject obj) /*-{
    if (this.@com.example.gwt.client.__AImpl::jsoPeer) {
      delete this.@com.example.gwt.client.__AImpl::jsoPeer.__gwtPeer;
    }
    if (!obj) {
      this.@com.example.gwt.client.__AImpl::jsoPeer = null;
      return this;
    }
    if (obj.__gwtPeer) {
      @com.google.gwt.jsio.client.impl.JSONWrapperUtil::throwMultipleWrapperException()();
    }
    this.@com.example.gwt.client.__AImpl::jsoPeer = obj;
    this.@com.example.gwt.client.__AImpl::jsoPeer.__gwtPeer = this;
    this.@com.example.gwt.client.__AImpl::__initializeEmptyFields(Lcom/google/gwt/core/client/JavaScriptObject;)(this.@com.example.gwt.client.__AImpl::jsoPeer);
    return this;
  }-*/;
  public final Extractor getExtractor() {
    return __extractor;
  }
  private final static Extractor __extractor = new Extractor() {public native Object fromJS(JavaScriptObject obj) /*-{
      return obj == null ? null : (obj.__gwtPeer || @com.example.gwt.client.__AImpl::__create__com_example_gwt_client_A()().@com.google.gwt.jsio.client.JSWrapper::setJavaScriptObject(Lcom/google/gwt/core/client/JavaScriptObject;)(obj));
    }-*/;
    public native JavaScriptObject toJS(Object obj) /*-{
      return obj == null ? null : obj.@com.google.gwt.jsio.client.JSWrapper::getJavaScriptObject()();
    }-*/;
  };
  private native void __initializeEmptyFields(JavaScriptObject jso) /*-{
  }-*/;
  public native void myMethod(com.example.gwt.client.B bObject) /*-{
    this.@com.example.gwt.client.__AImpl::jsoPeer.myMethod(bObject == null ? null : bObject.@com.google.gwt.jsio.client.JSWrapper::getJavaScriptObject()());
  }-*/;
  private static com.example.gwt.client.A __create__com_example_gwt_client_A() {
    return (com.example.gwt.client.A)GWT.create(com.example.gwt.client.A.class);
  }
}

}}}

__BImpl.java:

{{{
package com.example.gwt.client;

import com.google.gwt.jsio.client.impl.*;
import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.jsio.client.*;
import com.google.gwt.core.client.GWT;

public class __BImpl extends com.example.gwt.client.B {
  private JavaScriptObject jsoPeer;
  public __BImpl() {
    setJavaScriptObject(__nativeInit());
  }
  private native JavaScriptObject __nativeInit() /*-{
    return new $wnd.B();
  }-*/;
  public JavaScriptObject getJavaScriptObject() {
    return jsoPeer;
  }
  public void setJSONData(String data)
  throws JSONWrapperException {
    setJavaScriptObject(JSONWrapperUtil.evaluate(data));
  }
  public JSWrapper setJavaScriptObject(JavaScriptObject obj) {
    if (obj != null) {
    }
    return setJavaScriptObjectNative(obj);}
  public native JSWrapper setJavaScriptObjectNative(JavaScriptObject obj) /*-{
    if (this.@com.example.gwt.client.__BImpl::jsoPeer) {
      delete this.@com.example.gwt.client.__BImpl::jsoPeer.__gwtPeer;
    }
    if (!obj) {
      this.@com.example.gwt.client.__BImpl::jsoPeer = null;
      return this;
    }
    if (obj.__gwtPeer) {
      @com.google.gwt.jsio.client.impl.JSONWrapperUtil::throwMultipleWrapperException()();
    }
    this.@com.example.gwt.client.__BImpl::jsoPeer = obj;
    this.@com.example.gwt.client.__BImpl::jsoPeer.__gwtPeer = this;
    this.@com.example.gwt.client.__BImpl::__initializeEmptyFields(Lcom/google/gwt/core/client/JavaScriptObject;)(this.@com.example.gwt.client.__BImpl::jsoPeer);
    return this;
  }-*/;
  public final Extractor getExtractor() {
    return __extractor;
  }
  private final static Extractor __extractor = new Extractor() {public native Object fromJS(JavaScriptObject obj) /*-{
      return obj == null ? null : (obj.__gwtPeer || @com.example.gwt.client.__BImpl::__create__com_example_gwt_client_B()().@com.google.gwt.jsio.client.JSWrapper::setJavaScriptObject(Lcom/google/gwt/core/client/JavaScriptObject;)(obj));
    }-*/;
    public native JavaScriptObject toJS(Object obj) /*-{
      return obj == null ? null : obj.@com.google.gwt.jsio.client.JSWrapper::getJavaScriptObject()();
    }-*/;
  };
  private native void __initializeEmptyFields(JavaScriptObject jso) /*-{
    jso.retrieveMessage = function() {
      return this.__gwtPeer.@com.example.gwt.client.B::retrieveMessage()(
      );
    };
  }-*/;
  private static com.example.gwt.client.B __create__com_example_gwt_client_B() {
    return (com.example.gwt.client.B)GWT.create(com.example.gwt.client.B.class);
  }
}
}}}

=JSFlyweightWrapper interface=

The [http://gwt-api-interop.googlecode.com/svn/javadoc/com/google/gwt/jsio/client/JSFlyweightWrapper.html com.google.gwt.jsio.client.JSFlyweightWrapper] generates code so that multiple objects can share the same functions.  This cuts down on memory usage.

The tags are pretty much the same as JSWrapper, but you'll want to look at anything with a jsoPeer instance field.

New Annotations:

|| Annotation   || Location || Description ||
|| `gwt.binding` || Class || Indicates that a flyweight-style method should be used to bind exported functions from a type into a !JavaScriptObject.  This creates a property named `__gwtPeer` on the !JavaScriptObject that references the type. ||


New Methods:
 
|| Method Name  || Description ||
|| `createPeer()` || Used to initialize the generated instance with a !JavaScript object. ||


== Example JSFlyweightWrapper ==


The following example shows how to create a wrapper to the !TextThingo !JavaScript API above using the JSFlyweightWrapper interface and a constructor function.

=== Interface definition ===

The code is similar to the `JSWrapper` example, but a static instance of the generated class is created and stored within the Flyweight object.  Note that each accessor method contains a `JavaScriptObject` as the first parameter:

{{{
/**
 * @gwt.beanProperties
 */
public interface TextThingoFW extends JSFlyweightWrapper {

  public static final TextThingoFW impl = 
    (TextThingoFW) GWT.create(TextThingoFW.class);
  
  /**
   * @gwt.constructor $wnd.TextThingo
   */
  public JavaScriptObject construct(Element container, String value);

  /* Automatically created bean method to access option property */
  public String getTextValue(JavaScriptObject jsoPeer);

  /* Automatically created bean method to access option property */
  public void setTextValue(JavaScriptObject jsoPeer, String value);

  /* Maps to the JavaScript start() function on the TextThingo object */
  public void show(JavaScriptObject jsoPeer);
}
}}}


=== Instantiating the Interface with Deferred Binding ===


Now, to use the API, you access the generated instance through the
`impl` static variable.  The constructor will return a native
JavaScriptObject which you must use each time you wish to access the
object. 

{{{
  private JavaScriptObject jsoPeer;

  public void onModuleLoad() {
    Panel s = new SimplePanel();
    
    // Create an instance of a TextThingo in JavaScript, store away the resulting
    // JavaScript object for future calls through the TextThingoFW interface.
    jsoPeer = TextThingoFW.impl.construct(s.getElement(), "Hello Flyweight World!");   
    
    TextThingoFW.impl.setTextValue(jsoPeer, "Goodbye Cruel Flyweight World!");
    TextThingoFW.impl.show(jsoPeer);

    // Add the panel containing the text thingo to the interface.
    RootPanel.get("elementId").add(s);
  }
}}}

=== Generated Code ===

The following listing shows the output of the `JSFlyweightWrapper` generator.  It is much simpler than its `JSWrapper` counterpart, and more easily optimized by the compiler.

{{{
package com.example.gwt.client;

import com.google.gwt.jsio.client.impl.*;
import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.jsio.client.*;
import com.google.gwt.core.client.GWT;

public class __TextThingoFWImpl implements com.example.gwt.client.TextThingoFW {
  public native java.lang.String getTextValue(com.google.gwt.core.client.JavaScriptObject jsoPeer) /*-{
    return jsoPeer.textValue;
  }-*/;

  public native void setTextValue(com.google.gwt.core.client.JavaScriptObject jsoPeer, java.lang.String value) /*-{
    jsoPeer.textValue = value;
  }-*/;

  public native com.google.gwt.core.client.JavaScriptObject construct(com.google.gwt.user.client.Element container, java.lang.String value) /*-{
    var jsReturn = new $wnd.TextThingo(container, value);
    if (!jsReturn.hasOwnProperty('textValue')) {
      jsReturn.textValue = null;
    }
    return jsReturn;
  }-*/;

  public native void show(com.google.gwt.core.client.JavaScriptObject jsoPeer) /*-{
    jsoPeer.show();
  }-*/;
}
}}}

== Using a callback with !JSFlyweightWrapper ==

Consider the following !JavaScript API that takes a function as a parameter to some methods:

=== !JavaScript API ===

{{{
// Example of a JavaScript API that requires a callback function

// Constructor for the ThreeButton object
// e - element ot attach the three buttons to
// cb - callback to use whenever the buttons are pressed
// button1Name - string to use for text in button 1
// button2Name - string to use for text in button 2
function TwoButton (e, cb, button1Name, button2Name) {

  this.id = "TwoButton";
  
  this.button1 = document.createElement("button");
  button1Name = 
    button1Name !== undefined ? button1Name : "One";
  this.button1.appendChild(document.createTextNode(button1Name));
 
  this.button2 = document.createElement("button");
  button2Name = 
      button2Name !== undefined ? button2Name : "Two"; 
  this.button2.name = this.button2.value;

  this.button2.appendChild(document.createTextNode(button2Name));
  
  e.appendChild(this.button1);
  e.appendChild(this.button2);
  
  this.addCallback(cb);
}

// Change the callback function
// cb - callback to use whenever the buttons are pressed. 
//      Replaces the previous setting
TwoButton.prototype.addCallback = function (cb) {

  // Create a closure to use to invoke the callback function.  
  var meCb = function (buttonNumber) { cb (buttonNumber); };
  this.button1.onclick = function () { meCb(1) };
  this.button2.onclick = function () { meCb(2) };
}

}}}

=== Interface Definition ===

A JavaScript API that takes a function as a parameter requires creating a subclass of the `JSFunction` class.  The definition of `TwoButtonCallback` below allows the JavaScript API to invoke a Java function as a callback.

Note that we are fortunate in this instance, as the callback function's parameters consists only of JSIO compatible types.  See the rules for which types are compatible in the description of the `JSWrapper` interface above.

{{{
/**
 * A wrapper for the TwoButton JavaScript API.  This API requires
 * a callback function which we wish to specify in Java.
 */
public interface TwoButtonFW extends JSFlyweightWrapper {

  /**
   * A definition of a callback class.  Must extend JSFunction
   */
  public abstract static class TwoButtonCallback extends JSFunction {
    public abstract void callback (int buttonNumber);
  }
  
  public static final TwoButtonFW impl = 
    (TwoButtonFW) GWT.create(TwoButtonFW.class);
  
  /**
   * @gwt.constructor $wnd.TwoButton
   */
  public JavaScriptObject construct(
      Element container, TwoButtonCallback cb, String buttonOneText, 
      String buttonTwoText);
  
  /**
   * @gwt.beanProperties
   */
  public String getId(JavaScriptObject jsoPeer);
  
  public void addCallback (JavaScriptObject jsoPeer, TwoButtonCallback cb);
  
}
}}}

=== Instantiating the Interface ===

The following code demonstrates how to use the TwoButtonFW interface:

{{{
/**
 * This example shows how to use the wrapper class for the TwoButton JavaScript
 * API.  It instantiates an instance of TwoButton.  Each time the callback is
 * invoked, an alert window is display, then the callback is swaped between 
 * cb1 and cb2.
 */
public class JSFlyweightWrapperCallbackExample implements EntryPoint {

  private JavaScriptObject jsoPeer;
  private TwoButtonCallback cb2;
  private TwoButtonCallback cb1;

  public void onModuleLoad() {
    Panel s = new SimplePanel();

    cb1 = new TwoButtonCallback() {
      @Override
      public void callback(int buttonNumber) {
        Window.alert("Got TwoButton Callback for button: " + buttonNumber);
        TwoButtonFW.impl.addCallback(jsoPeer, cb2);
      }
    };

    cb2 = new TwoButtonCallback() {
      @Override
      public void callback(int buttonNumber) {
        Window.alert("Replaced callback. Got button: " + buttonNumber);
        TwoButtonFW.impl.addCallback(jsoPeer, cb1);
      }
    };

    jsoPeer = TwoButtonFW.impl.construct(s.getElement(), cb1, "Button One (1)",
        "Button Two (2)");

    // Add the panel containing the TwoButton object to the interface.
    RootPanel.get("elementId").add(s);
  }
}
}}}


= Class Documentation =

[http://gwt-api-interop.googlecode.com/svn/javadoc/index.html Javadoc Index]
