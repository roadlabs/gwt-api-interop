#summary The JavaScript Interoperability (JSIO) library simplifies binding a JavaScript API to GWT
= Introduction =

This document describes the JavaScript Interoperability( JSIO) library for the Google Web Toolkit (GWT).  These classes are for importing existing JavaScript APIs and exporting Java functions to be used JavaScript code.

Using this library, the GWT compiler can automatically generate:

    * Linkage to functions defined within a `{@link com.google.gwt.core.client.JavaScriptObject}`
    * Exports of Java functions to be made available to !JavaScript callers
    * Accessors for bean-style properties

Developers extend `JSWrapper` or` JSFlyweightWrappe`r to create interface definitions to access the !JavaScript object.  To use the interface, the GWT deferred binding mechanism `GWT.create()` is invoked to return an instance of the interface created through automatically generated code.

=JSWrapper interface=

Any method defined in an interface that extends `{@link com.google.gwt.jsio.client.JSWrapper}` or an abstract method in a class that implements {@link com.google.gwt.jsio.client.JSWrapper} will be acted upon by the compiler. The default behavior is to invoke an identically-named method on the underlying {@link com.google.gwt.core.client.JavaScriptObject}. This behavior may be altered by the presence of various annotations on the class and its methods.

The parameter and return types supported by JSWrapper are:

    * primitive
    * boxed primitive
    * {@link java.lang.String}
    * {@link com.google.gwt.jsio.client.JSFunction}
    * {@link com.google.gwt.jsio.client.JSWrapper}
    * {@link com.google.gwt.jsio.client.JSList} having a compatible component type specified with the gwt.typeArgs annotation
    * {@link com.google.gwt.core.client.JavaScriptObject} and subtypes
    * {@link com.google.gwt.jsio.client.JSOpaque} as a method parameter only.

In the general case, there may be at most one {@link com.google.gwt.jsio.client.JSWrapper} associated with a {@link com.google.gwt.core.client.JavaScriptObject}. This allows the JSWrapper to maintain an object identity equivalent to that of the underlying !JavaScriptObject. This is done by adding an additional property, `__gwtObject`, to the !JavaScriptObject.
Annotations

The behavior of the generated classes may be altered by the presence of various @gwt annotations.

||Annotation 	        ||Location 	||Description ||
|| `gwt.beanProperties`    ||Class, Method || Indicates that methods that look like bean-style property setters (methods that begin with the prefix `get`, `set`, or `is`) should be generated so as to read and write object properties rather than import functions. This is most useful with JSON-style objects. The setting may by applied on a per-method basis in an imported class and may by overridden on a per-method basis by `gwt.imported`. If the backing object does not contain data for a property accessor, null, 0, ' ', false, or an empty {@link com.google.gwt.jsio.client.JSList} will be returned. ||
|| `gwt.constructor` 	||Class, Method  || The annotation `gwt.constructor` may be applied to a class to specify a JavaScript function to execute when constructing a JSWrapper to use as the initial backing object. A JavaScript Date object could be created by using the value $wnd.Date. If the gwt.constructor annotation is applied to a method within a JSWrapper and the method invoked, the parameters of the method will be passed to the named global function and the resulting JavaScript object will be used as the backing object. ||
|| `gwt.exported` 	||Method 	||Individual Java functions may be exported to JavaScript callers by declaring a gwt.exported annotation on a concrete Java method within a JSWrapper. The Java method will be bound to a property on the backing object per the class' NamePolicy or a `gwt.fieldName` annotation on the method. When applied at the class level to a {@link com.google.gwt.jsio.client.JSFunction}, it specifies which of the methods declared within to type to export as a JavaScript Function object.||
|| `gwt.fieldName` 	||Method 	||When implementing a bean property accessor, the default NamePolicy will be used unless a `gwt.fieldName` annotation appears on the property's getter or setter. This is also used with imported and exported functions to specify the object property to attach to.||
|| `gwt.global` 	||Class 	||The annotation `gwt.global` is similar to gwt.constructor, however it may be applied only at the class level and the value is interpreted as a globally-accessible object name, rather than a function. ||
|| `gwt.imported` 	||Method 	||This is an override for methods within classes annotated with `gwt.beanProperties`.||
|| `gwt.namePolicy` 	||Class 	||Specifies the default transformation to use when converting bean property accessor function names to fields on the underlying !JavaScriptObject. The valid values for the namePolicy are the field names on the {@link com.google.gwt.jsio.rebind.NamePolicy} class, or the name of a class that implements NamePolicy.||
|| `gwt.noIdentity` 	||Class 	||This annotation suppresses the addition of the __gwtObject property on the underlying !JavaScriptObject. The object identity of the JSWrapper will no longer maintain a 1:1 correspondence with the underlying !JavaScriptObject. Additionally, {@link com.google.gwt.jsio.client.JSWrapper#setJavaScriptObject} will no longer throw {@link com.google.gwt.jsio.client.MultipleWrapperException}.  ||
|| `gwt.readOnly`	||Class 	||This prevents the generated JSWrapper implementation from containing any code that will modify the underlying !JavaScriptObject. This implies `gwt.noIdentity`. Invoking a bean-style getter when the underlying !JavaScriptObject does not contain a value for the property will result in undefined behavior. ||

== Generated Code ==

TODO: Show code generated from an example JSWrapper use case

==JSWrapper Examples==

The following examples demonstrate how to write an interface that maps onto a JavaScript object to access it from GWT code.


=== Hello World using JSWrapper ===

This simple example demonstrates how to access a property in a JavaScript Object (JSO).

{{{
/*
 * HelloJSIO.java
 * A simple wrapper around a single JavaScript object property named 'hello'
 */

/**
 * @gwt.beanProperties
 */
interface HelloWrapper extends JSWrapper {
  public String getHello();
}
HelloWrapper hello = (HelloWrapper)GWT.create(HelloWrapper.class);
hello.setJSONData("{hello:'Hello world'}");
Window.alert(hello.getHello());
}}}


=== Mixing Access to JavaScript Object with other methods ===

The following example uses several JSIO features:

 * Some bean accessor methods are created.
 * A concrete Java method is defined in the JSO.
 * A JavaScript function is imported from JavaScript to Java.

{{{
/**
 * @gwt.beanProperties
 */
abstract class MixedWrapper implements JSWrapper {

  // Property accessor - read the property named 'a'
  public abstract int getA();

  // Property accessor - read the property named 'b'
  public abstract int getB();

  // Property accessor - write to the prperty named 'b'
  public abstract int setB();

  // Method that is implemented in Java that will be translated to 
  // JavaScript and set in the JavaScript Object.
  public int multiply() {
    return getA() * getB();
  }

  // This method would be imported at some point. JSIO supports 
  // "duck-typing" - if no function with the name 'importedFunction()' 
  // is defined in the object at the time the method is invoked, 
  // you will get a run-time error.
  public abstract int importedFunction(String s);

}
}}}

The following demonstrates how to use the new wrapper:

{{{
MixedWrapper wrapper = (MixedWrapper)GWT.create(MixedWrapper.class);
wrapper.setJSONData("{a:2, b:5}");
Window.alert(wrapper.multiply());
wrapper.setB(10);
Window.alert(wrapper.multiply());
}}}

Running the code would show you the value `10` in the first window, then `20` in the second window.


=JSFlyweightWrapper interface=

The JSFlyweightWrapper generates code so that mutliple objects can share the same functions.  This cuts down on memory usage.

TODO: Show code generated from an example JSFlyweightWrapper use case

The tags are pretty much the same as JSWrapper, but you'll want to look at anything with a jsoPeer instance field.

New Annotations:

|| Annotation   || Location || Description ||
|| `gwt.binding` || Class || Indicates that a flyweight-style method should be used to bind exported functions from a type into a !JavaScriptObject. ||


New Methods:
 
|| Method Name  || Description ||
|| `createPeer()` || Used to initialize the generated instance with a JavaScript object. ||


==Example JSFlyweightWrapper==

{{{
}}}
